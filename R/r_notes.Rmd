# R Notes 
Sources:
1. [Mastering Health Science Using R](https://alicepaul.github.io/health-data-science-using-r/book.html)

*Keyboard shortcuts:*
- `<-` (assignment operator)
  - Windows: Alt + -
  - Mac: Option + -
- `%>%` (pipe operator)
  - Windows: Ctrl+Shift+M 
  - Mac: Cmd+Shift+M 
- (Un)Comment Selection
  - Windows: Ctrl+Shift+C 
  - Mac: Cmd+Shift+C 
___
## Basics of R 
### Basic Computations Objects
- Addition: `+`
- Subtraction: `-`
- Multiplication: `*`
- Division: `/`
- Exponentiation: `^`
- Modulo: `%%`
___
- **objects** are values used in R 
  - a **variable** is an object
  - an object is a named instance of a data structure
  - data structures in R are **vectors**, **factors**, **matrices**, **arrays**, **lists**, and **data frames**
- to store any computation or value as a variable you would use the assignment operator:
  - `x <- 2+3`

- calling a function is: `function_name()`
  - examples of functions:
    - `ceiling()` returns the ceiling (an upper usually prescribed limit) of your input
    - `floor()` returns the floor (a lower usually prescribed limit) of your input 
    - `round()` rounds your input to the closest integer - it rounds a number in 0.5 to the closest even integer:
      - ex: 2.5 = 2; 3.5 = 4
___
- to see what the current working directory is you would use `getwd()`
  - to change the working directory, you would use `setwd()`
___
- before you do anything else, you need to install packages that are used in R 
  - the most important one is `tidyverse`
    - `install.packages('tidyverse')`
      - to call the package: `library(tidyverse)`
___
## Data Structures in R 
- each individual value in R has a type: **logical**, **integer**, **double** or **character**
  - you can use `typeof()` to find the type of vector 
- **double** is a numeric value with a stored decimal
- an **integer** is a whole number without a decimal
  - to indicate we want the number to be an integer object, you need to use `L` after the number 
- **characters** have letters
- **logicals** or **booleans** are `TRUE` and `FALSE`
  - **booleans** can actually be interpreted as `0`/`1` and can be used in logic: ex: `TRUE + FALSE + TRUE` = 2
### Vectors 
- Vectors are one-dimensional data structures that cna store multiple data types of the same type (ex: character, Boolean, numeric)
- You can confirm if something is a vector by using: `is.vector()`
- Creating a vector:
  - combine multiple values using the `c()` function 
    - vectors can only store the same type of value, so if you try and combine a string and a integer, it will convert the integer to a string 
    - the `class()` function returns the data structure of an object 
    - you can create an empty vectio by leaving the `c()` blank
      - you can also set the type of the empty vector:
        - `ex_empty <- vector(mode="numeric")`
  - you can create a vector with `req()` or `seq()`
    - `req(x, times)` takes the value (x) and a number of times and outputs x the number of times entered
    - `seq(from, to step)` takes a numeric starting value (from) and an end value (to) and step size (step) which specifies the sequence to get from the **from** to the **to** value (or the maximum that can get close based on the step value)

#### Indexing a vector 
- when a vector is created, you can access certain values in it by indexing []
  - `vector[1]`
- not only can you access a single value, but a subset of the values using `c()`
  - `vector[c(1,4)]`
- another option is to associate a name with each value
  - `names(rain) <- days`
- another option is using `TRUE` and `FALSE` values to index the values in a vector (both vectors need to be the same length)
  - so when you index the vector, it will only show the `TRUE` values

#### Modifying a Vector and Calculations
- exp() - exponential
- log() - log
- sqrt() - square root
- abs() - absolute value
- round() - round to nearest integer value
- ceiling() - round up to the nearest integer value
- floor() - round down to the nearest integer value
- signif(, dig) - round to dig number of significant digits
- the above logical functions can be used to combine vectors or as operators on vector values
- you can also change values in a vector: `rain["Friday"] <- 0.5`
- adding additional entries to a vector is possible too 
  - `days <- c(days, "Saturday", "Sunday")`
  - to check the current length of a vector, you can use the `length()` function 
- you can also get the sum, max, and min of a vector using the functions:
  - `sum()`
  - `max()`
  - `min()`

#### Common Vector Functions
- below are some of the most common vector functions available in R 
- sum() - summation
- median() - median value
- mean() - mean
- sd() - standard deviation
- var() - variance
- max() - maximum value
- which.max() - index of the first element with the maximum value
- min() - minimum value
- which.min() - index of the first element with the minimum value

- you can also use the `sort()` function to sort the values
- and the `order()` function to see the order of the values which have the smallest and highest values
- for both `order()` and `sort()`, they have the extra argument of `decreasing` which can be set to either `TRUE` or `FALSE`

### Factors 
- a special kind of vector that behaves like a regular vector, except that it represents values from a category
- it keeps track of all possible values of that category in what are called levels of the factor 
- the function `as.factor()` converts a vector to a factor
  - using the `factor()` function instead of `as.factor()` will let you specify the levels of the factor even if there are more levels that current values of the factor 
  ```r 
  days_fct <- factor(days, 
                    levels = c("Monday", "Tuesday", "Wednesday", 
                                "Thursday", "Friday", "Saturday", "Sunday"))
  ```
- you may not have all the values in the factor as what you are specifying in the levels but thats just telling when a new value is inserted, what level the new value will take
- factors can also be used for numeric vectors 
- if we want to have 0/1 to represent whether a day is a weekend or not, this is something we can do with factor levels

### Matrices 
- similar to vectors in that they store data of the same type but matrices are two-dimensional and consist of rows and columns 
- matrices can be created using the matric() function
  - `matrix(data, nrow, ncol, byrow)`
    - **data** are the values (and are often used with the `c()` function)
    - **nrow** is the number of rows
    - **ncol** is the number of columns
    - **byrow** is either `TRUE` if you want the data values to be filled in by row or `FALSE` if its by columns
- to find the dimensions of the matrix, you can use `nrow()`, `ncol()`, or `dim()`
  - `nrow()` returns how many rows there are 
  - `ncol()` returns how many columns there are 
  - `dim()` returns how many rows and columns there are

#### Indexing a Matrix 
- as opposed to vectors, since there are rows and columns, you need to know both when trying to index a value in a matrix
  - `rainfall[1, 4]`
- you can provide multiple indexes to return multiple values
  - `rainfall[1, c(4, 5, 7)]`
- you can also index by boolean
  - `rainfall[c(FALSE, TRUE), ]`
- we can also specify row and column names in the indices
- `colnames()` and `rownames()` returns the names of the rows and columns

#### Modifying a Matrix
- to change the values in a matrix, you need to index the values first and then assign new values
- the functions `rbind()` and `cbind()` can add rows and columns 
  - `rainfall <- rbind(rainfall, "Week3" = c(0.4, 0.0, 0.0, 0.0, 1.2, 2.2, 0.0))` this will add a new row with values 
  - `rainfall <- cbind(rainfall, "Total" = c(7.1, 2.4, 3.8))` this will add a new column with values
- you can bind matrices together using `cbind()`, but you need to make sure they are the same size
- you can also use mathematical operators to combine too: `A+B` or perform mathematics on the matrix: `exp(C)`

### Data Frames
- like matrices, they store data in rows and columns, but you can use different data types
- you can create a data frame from data using the `data.frame()` function
  - the `head()` function prints the first six rows of a data frame
  - the `tail()` function prints the last six rows of a data frame
- you can use the same `dim()`, `nrow()`, `ncol()` as you would with a matrix 
- the same with `colnames()` or you can even just use `names()`

#### Indexing a Data Frame
- done the same way as with a matrix 
- you can also use `$` for accessing the column names: `weather_data$day_of_week`

#### Modifying a Data Frame
- can also modify the data the same as with a matrix 
- can also combine data frames using the `rbind()` or `cbind()` but can also use `$`

### Lists 
- a data frame is actually a special type of another data structure called a list
- a list is a collection of objects under the same name
- these objects can be vectors, matrices, data frames, or even other lists
- they don't have to be the same size, type, or any other matching attribute
- when printing indexes, it will return the sublist of values you are indexing
- you can specify to return just the values themselves by using double brackets: `ex_list[[2]]`
- you can also just name of the elements of a list to make indexing and manipulating easier:
```r 
ex_list <- list(name="John",
                medication=c("ibuprofen", "metformin"),
                past_weights=c(136, 142, 159))
```
___
## Working with Data Files in R 

- Tab-Delimited Files: You can read in a tab-separated .txt file using the read.delim() function in base R.
- Excel Files: You can read in a .xls or .xlsx file using readxl::read_excel(), which allows you to specify a sheet and/or cell range within a file (e.g., read_excel('test.xlsx', sheet="Sheet1")).
- SAS: haven::read_sas() reads in .sas7bdat or .sas7bcat files, haven::read_xpt() reads in SAS transport files.
- Stata: haven::read_dta() reads in .dta files.
- SPSS: haven::read_spss() reads in .spss files.

- to explore the distribution and ranges of the values in certain columns, you can use the `summary()` function
  - if there are any NA values in the column, you can use the argument `na.rm=TRUE` to remove the NAs or else some of the results will just be NA
- `min(pain$PAIN_INTENSITY_AVERAGE, na.rm=TRUE)` returns the minimum value for a numeric vector
- `max(pain$PAIN_INTENSITY_AVERAGE, na.rm=TRUE)` returns the maximum value for a numeric vector
- `mean(pain$PAIN_INTENSITY_AVERAGE, na.rm=TRUE)` returns the mean for a numeric vector
- `median(pain$PAIN_INTENSITY_AVERAGE, na.rm=TRUE)` returns the median for a numeric vector
- `range(pain$PAIN_INTENSITY_AVERAGE, na.rm=TRUE)` returns the minimum and maximum values for a numeric vector x
- `quantile(pain$PAIN_INTENSITY_AVERAGE, na.rm=TRUE)` returns the sample quantiles for a numeric vector
- `IQR(pain$PAIN_INTENSITY_AVERAGE, na.rm=TRUE)` returns the interquartile range for a numeric vector
- by default the quantile() function returns the sample quantiles but you can specify which quantiles you want to use
  - `quantile(pain$PAIN_INTENSITY_AVERAGE, probs = c(0.1, 0.9), na.rm=TRUE)`

- you can also see the distribution of values in a numeric column by using the `hist()` function

- the `summary()` function works with categorical columns too but will just return the counts for each level
  - it is easier to see the output by using the `table()` function: `table(pain$PAT_SEX, use="always")`
    - the `useNA` argument will show if there are any NA values in the table because by default it ignores NA's in the output
- using the `prob.table()` function will convert the counts to proportions (what percentage of the total values is the categorical value)
- you can also take a subset of the data and store it into a new dataframe

- the `pmax()` function is to find the maximum value between two columns

- another useful function that allows us to perform computations over the rows or columns of a matrix or data frame is the `apply(X, MARGIN, FUN)` function
  - the `X` is the data frame or matrix
  - the `MARGIN` indicates whether to compute over the rows (1) or columns(2)
  - the `FUN` argument is the function to apply across that MARGIN
- you can also use `colSums()` to find the sum of the columns

### Missing Infinite and NaN Values