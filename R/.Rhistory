#
# Please note that this program will replace the dataset in the default
# directory, if one is present.
#
# For details and guidance on how to properly conduct statistical analyses
# with these data, including the appropriate use of weights to create
# nationally representative estimates, please refer to the technical
# documentation that accompanies the 2023 NAMCS Health Center Component.
#
# For any questions, suggestions, or comments concerning NAMCS HC Component data,
# please contact the Division of Health Care Statistics at ambcare@cdc.gov.
# -------------------------------------------------------------------------
# Install and Load Packages
install.packages("tidyverse")
# Read in NAMCS HC 2023  Public Use File R Dataset
namcshc2023 <- read_rds("//C://namcshc2023//namcshc2023_r.rds")
namcshc2023 <- read_rds("//C://namcshc2023//namcshc2023_r.rds")
# Install and Load Packages
install.packages("tidyverse")
# Install and Load Packages
install.packages("tidyverse")
Yeslibrary("tidyverse")
# Install and Load Packages
install.packages("tidyverse")
install.packages("systemfonts", type = "source")
install.packages("ragg", type = "source")
# 1. Getting Started with R
# 1.2.1 Basic Computations Objects
# Addition
5+6
# if you want to run all lines of code in our script, you would use the source button but
# you can use the source function
source("Mastering_Health_Science_Using_R.R")
# calling a function
# ceiling() returns the ceiling of your input
# floor() returns the floor of your input
# round() rounds your input to the closest integer
ceiling(3.7)
# you can also see what the current working directory is by using getwd()
getwd()
# to set the current working directory, you can use setwd()
setwd('/Users/carolinesanicola/Documents/GitHub/important-reference-repo/R')
# check
getwd()
# now update the path to the csv file
df <- read.csv("https://github.com/alicepaul/health-data-science-using-r/blob/main/book/data/fake_names.csv")
# now update the path to the csv file
df <- read.csv("https://github.com/alicepaul/health-data-science-using-r/blob/b71bbec95709d0107c166d97654890b9500678ef/book/data/fake_names.csv")
# now update the path to the csv file
df <- read.csv("https://raw.githubusercontent.com/alicepaul/health-data-science-using-r/b71bbec95709d0107c166d97654890b9500678ef/book/data/fake_names.csv")
df
# the most important thing to do is download packages and one of the most important is 'tidyverse'
# to see what packages are already installed use `installed.packages()`
installed.packages()
# the most important package to download is tidyverse
install.package('todyverse')
# the most important package to download is tidyverse
install.packages('tidyverse')
library(tidyverse)
# an object is a named instance of a data structure
ex_num <- 4
# 2.1 Data Types
# each individual value in R has a type: logical, integer, double or character
# you can use typeof() function to find the type of vector
typeof(ex_num)
typeof(ex_int)
# double is a numeric value with a stored decimal
# an integer is a whole number without a decimal
# to indicate we want the number to be an integer object, you need to use `L` after the number
ex_int <- 4L
typeof(ex_int)
# characters have letters
ex_char <- "Alice"
# logicals or booleans are TRUE and FALSE
ex_bool <- TRUE
typeof(ex_char)
typeof(ex_bool)
# booleans can actually be interpreted as 0/1 and can be used in logic
TRUE + FALSE + TRUE
library("tidyverse")
library("nycflights13")
install.packages("ggbeeswarm")
library("ggbeeswarm")
install.packages("lvplot")
library("lvplot")
install.packages("ggstance")
library("ggstance")
nycflights13::flights %>%
mutate(
cancelled = is.na(dep_time),
sched_hour = sched_dep_time %/% 100,
sched_min = sched_dep_time %% 100,
sched_dep_time = sched_hour + sched_min / 60
) %>%
ggplot(aes(x = sched_dep_time)) +
geom_freqpoly(aes(color = cancelled), bunwidth = 1/4)
nycflights13::flights |>
mutate(
cancelled = is.na(dep_time),
sched_hour = sched_dep_time %/% 100,
sched_min = sched_dep_time %% 100,
sched_dep_time = sched_hour + (sched_min / 60)
) |>
ggplot(aes(x = sched_dep_time)) +
geom_freqpoly(aes(color = cancelled), binwidth = 1/4)
nycflights13::flights %>%
mutate(
cancelled = is.na(dep_time),
sched_hour = sched_dep_time %/% 100,
sched_min = sched_dep_time %% 100,
sched_dep_time = sched_hour + sched_min / 60
) %>%
ggplot() +
geom_boxplot(mapping = aes(y = sched_dep_time, x = cancelled))
mean(c(0, 1, 2, NA), na.rm = TRUE)
sum(c(0, 1, 2, NA), na.rm = TRUE)
nycflights13::flights %>%
mutate(
cancelled = is.na(dep_time),
sched_hour = sched_dep_time %/% 100,
sched_min - sched_dep_time %/% 100,
sched_dep_time = sched_hour + sched_min / 60
) %>%
ggplot() +
geom_boxplot(mapping = aes(y = sched_dep_time, x = cancelled))
nycflights13::flights %>%
mutate(
cancelled = is.na(dep_time),
sched_hour = sched_dep_time %/% 100,
sched_min = sched_dep_time %/% 100,
sched_dep_time = sched_hour + sched_min / 60
) %>%
ggplot() +
geom_boxplot(mapping = aes(y = sched_dep_time, x = cancelled))
ggplot(diamonds, aes(x = price)) +
geom_freqpoly(aes(color = cut), binwidth = 500, linewidth = 1)
ggplot(diamonds, aes(x = price)) +
geom_freqpoly(aes(color = cut), binwidth = 500, linewidth = 0.75)
ggplot(diamonds, aes(x = price)) +
geom_freqpoly(aes(color = cut), binwidth = 500, linewidth = 1)
ggplot(mpg, aes(x = class, y = hwy)) +
geom_boxplot()
ggplot(mpg, aes(x = fct_reorder(class, hwy, median), y = hwy)) + # the previous defaulted to alphabetical order for class but if we want to sort it by median value instead then you would use fct_reorder and specify how you want it reordered
geom_boxplot()
ggplot(mpg, aes(y = hwy, x = fct_reorder(class, hwy, median))) + # since the names are long, we want to make the display horizontal and you would do that by switching the x and y
geom_boxplot()
ggplot(mpg, aes(x = fct_reorder(class, hwy, median), y = hwy)) + # the previous defaulted to alphabetical order for class but if we want to sort it by median value instead then you would use fct_reorder and specify how you want it reordered
geom_boxplot()
ggplot(mpg, aes(y = hwy, x = fct_reorder(class, hwy, median))) + # since the names are long, we want to make the display horizontal and you would do that by switching the x and y
geom_boxplot()
ggplot(mpg, aes(x = hwy, y = fct_reorder(class, hwy, median))) + # since the names are long, we want to make the display horizontal and you would do that by switching the x and y
geom_boxplot()
nycflights13::flights %>%
mutate(
cancelled = is.na(dep_time),
sched_hour = sched_dep_time %/% 100,
sched_min = sched_dep_time %% 100,
sched_dep_time = sched_hour + sched_min / 60
) %>%
ggplot() +
geom_boxplot(mapping = aes(y = sched_dep_time, x = cancelled))
ggplot(nycflights13::flights, aes(x = scheduled_dep_time, y = after_stat(density))) +
geom_freqpoly(aes(color = cancelled))
nycflights13::flights |>
mutate(
cancelled = is.na(dep_time),
sched_hour = sched_dep_time %/% 100,
sched_min = sched_dep_time %% 100,
sched_dep_time = sched_hour + (sched_min / 60)
) |>
ggplot(aes(x = sched_dep_time)) +
geom_freqpoly(aes(color = cancelled), binwidth = 1/4)
nycflights13::flights |>
mutate(
cancelled = is.na(dep_time),
sched_hour = sched_dep_time %/% 100,
sched_min = sched_dep_time %% 100,
sched_dep_time = sched_hour + (sched_min / 60)
) |>
ggplot(aes(x = sched_dep_time)) +
geom_freqpoly(aes(color = cancelled), binwidth = 500)
nycflights13::flights |>
mutate(
cancelled = is.na(dep_time),
sched_hour = sched_dep_time %/% 100,
sched_min = sched_dep_time %% 100,
sched_dep_time = sched_hour + (sched_min / 60)
) |>
ggplot(aes(x = sched_dep_time)) +
geom_freqpoly(aes(color = cancelled), binwidth = 1)
nycflights13::flights |>
mutate(
cancelled = is.na(dep_time),
sched_hour = sched_dep_time %/% 100,
sched_min = sched_dep_time %% 100,
sched_dep_time = sched_hour + (sched_min / 60)
) |>
ggplot(aes(x = sched_dep_time)) +
geom_freqpoly(aes(color = cancelled), binwidth = 1/2)
ggplot(flights_data, aes(x = scheduled_dep_time, fill = cancelled)) +
geom_bar(position = "identity", alpha = 0.6) + # Use position="identity" for overlapping bars
facet_wrap(~cancelled, scales = "free_y") + # Key: scales="free_y" for different y-axes
labs(title = "Flight Cancellations by Scheduled Departure Time",
x = "Scheduled Departure Time",
y = "Count",
fill = "Cancelled") +
theme_minimal()
ggplot(nycflights13::flights, aes(x = scheduled_dep_time, fill = cancelled)) +
geom_bar(position = "identity", alpha = 0.6) + # Use position="identity" for overlapping bars
facet_wrap(~cancelled, scales = "free_y") + # Key: scales="free_y" for different y-axes
labs(title = "Flight Cancellations by Scheduled Departure Time",
x = "Scheduled Departure Time",
y = "Count",
fill = "Cancelled") +
theme_minimal()
nycflights13::flights %>%
mutate(
cancelled = is.na(dep_time),
sched_hour = sched_dep_time %/% 100,
sched_min = sched_dep_time %% 100,
sched_dep_time = sched_hour + sched_min / 60
) %>%
ggplot(mapping = aes(x=sched_dep_time, y=..density..)) +
geom_freqpoly(mapping = aes(colour = cancelled), binwidth = .25)+
xlim(c(5,25))
nycflights13::flights %>%
mutate(
cancelled = is.na(dep_time),
sched_hour = sched_dep_time %/% 100,
sched_min = sched_dep_time %% 100,
sched_dep_time = sched_hour + sched_min / 60
) %>%
ggplot(mapping = aes(x=sched_dep_time)) +
geom_density(mapping = aes(fill = cancelled), alpha = 0.30)+
xlim(c(5,25))
nycflights13::flights %>%
mutate(
cancelled = is.na(dep_time),
sched_hour = sched_dep_time %/% 100,
sched_min = sched_dep_time %% 100,
sched_dep_time = sched_hour + sched_min / 60
) %>%
ggplot() +
geom_boxplot(mapping = aes(y = sched_dep_time, x = cancelled))
diamonds?
diamonds?
?diamonds
?diamonds
ggplot(diamonds, aes(x = price, y = cut)) +
geom_boxplot()
###
?diamonds
ggplot(diamonds, aes(x = price, y = carat)) +
geom_boxplot()
###
?diamonds
ggplot(diamonds, aes(x = price, y = color)) +
geom_boxplot()
ggplot(diamonds, aes(x = price, y = clarity)) +
geom_boxplot()
ggplot(diamonds, aes(x = price, y = color)) +
geom_boxplot()
ggplot(data = diamonds, mapping = aes(x = carat, y = price)) +
geom_boxplot(mapping = aes(group = cut_width(carat, 0.1)), orientation = "x")
install.packages("ggstance")
library(ggstance)
coord_flip()?
coord_flip()?
?coord_flip()
ggplot(data = mpg) +
geom_boxplot(mapping = aes(x = reorder(class, hwy, FUN = median), y = hwy)) +
coord_flip()
ggplot(data = mpg) +
geom_boxplot(mapping = aes(y = reorder(class, hwy, FUN = median), x = hwy)) +
coord_flip()
ggplot(data = mpg) +
geom_boxplot(mapping = aes(y = reorder(class, hwy, FUN = median), x = hwy)) +
coord_flip()
ggplot(data = mpg) +
geom_boxplot(mapping = aes(x = reorder(class, hwy, FUN = median), y = hwy)) +
coord_flip()
ggplot(data = mpg) +
geom_boxplot(mapping = aes(y = reorder(class, hwy, FUN = median), x = hwy))
ggplot(data = mpg) +
geom_boxplot(mapping = aes(x = reorder(class, hwy, FUN = median), y = hwy)) +
coord_flip() # this plot shows
ggplot(data = mpg) +
geom_boxplot(mapping = aes(y = reorder(class, hwy, FUN = median), x = hwy))
ggplot(data = mpg) +
geom_boxplot(mapping = aes(y = reorder(class, hwy, FUN = median), x = hwy), orientation = "y")
ggplot(data = mpg) +
geom_boxplot(mapping = aes(y = reorder(class, hwy, FUN = median), x = hwy), orientation = "x") # but you can also explicitly specify the orientation too
ggplot(data = mpg) +
geom_boxplot(mapping = aes(y = reorder(class, hwy, FUN = median), x = hwy), orientation = "y") # but you can also explicitly specify the orientation too
install.packages("lvplot")
library(lvplot)
?geom_lv
ggplot(diamonds, aes(price, cut))
?geom_lv
ggplot(diamonds, aes(price, cut)) +
geom_lv()
ggplot(diamonds, aes(x = price, y = cut)) +
geom_lv()
ggplot(diamonds, aes(x = cut, y = price)) +
geom_lv()
ggplot(diamonds, aes(x = price, y = cut)) +
geom_lv()
ggplot(diamonds, aes(x = cut, y = price)) +
geom_lv()
###
?geom_violin
ggplot(data = diamonds, mapping = aes(x = price, y = ..density..)) +
geom_freqpoly(mapping = aes(color = cut), binwidth = 500)
ggplot(data = diamonds, mapping = aes(x = price)) +
geom_histogram() +
facet_wrap(~cut, ncol = 1, scales = "free_y")
ggplot(data = diamonds, mapping = aes(x = cut, y = price)) +
geom_violin() +
coord_flip()
ggplot(data = diamonds, mapping = aes(x = price)) +
geom_histogram()
ggplot(data = diamonds, mapping = aes(x = price)) +
geom_histogram() +
facet_wrap(~cut, ncol = 1, scales = "free_y")
ggplot(data = diamonds, mapping = aes(x = cut, y = price)) +
geom_violin() +
coord_flip()
ggplot(data = diamonds, mapping = aes(x = price, y = ..density..)) +
geom_freqpoly(mapping = aes(color = cut), binwidth = 500)
ggplot(data = diamonds, mapping = aes(x = price)) +
geom_histogram() +
facet_wrap(~cut, ncol = 1, scales = "free_y")
ggplot(data = diamonds, mapping = aes(x = cut, y = price)) +
geom_violin() +
coord_flip()
install.packages("ggbeeswarm")
library(ggbeeswarm)
?geom_jitter
?ggbeeswarm
?geom_quasirandom
?geom_beeswarm
ggplot(data = mpg) +
geom_quasirandom(mapping = aes(
x = reorder(class, hwy, FUN = median),
y = hwy
))
ggplot(data = mpg) +
geom_quasirandom(
mapping = aes(
x = reorder(class, hwy, FUN = median),
y = hwy
),
method = "tukey"
)
ggplot(data = mpg) +
geom_quasirandom(
mapping = aes(
x = reorder(class, hwy, FUN = median),
y = hwy
),
method = "tukeyDense"
)
ggplot(data = mpg) +
geom_quasirandom(
mapping = aes(
x = reorder(class, hwy, FUN = median),
y = hwy
),
method = "frowney"
)
ggplot(data = mpg) +
geom_quasirandom(
mapping = aes(
x = reorder(class, hwy, FUN = median),
y = hwy
),
method = "smiley"
)
ggplot(data = mpg) +
geom_beeswarm(mapping = aes(
x = reorder(class, hwy, FUN = median),
y = hwy
))
ggplot(diamonds, aes(x = cut, y = color)) +
geom_count()
diamonds %>%
count(color, cut)
diamonds %>%
count(color, cut) %>%
ggplot(aes(x = color, y = cut)) +
geom_tile(aes(fill = n))
diamonds %>%
count(color, cut) %>%
group_by(color) %>%
mutate(prop = n / sum(n)) %>%
ggplot(mapping = aes(x = color, y = cut)) +
geom_tile(mapping = aes(fill = prop))
diamonds %>%
count(color, cut) %>%
group_by(cut) %>%
mutate(prop = n / sum(n)) %>%
ggplot(mapping = aes(x = color, y = cut)) +
geom_tile(mapping = aes(fill = prop))
###
?geom_tile
flights %>%
group_by(month, dest) %>%
summarise(sep_delay = mean(dep_delay, na.rm = TRUE)) %>%
ggplot(aes(x = factor(month), y = dest, fill = dep_delay)) +
geom_tile() +
labs(x = "Month", y = "Destination", fill = "Departure Delay")
flights %>%
group_by(month, dest) %>%
summarise(dep_delay = mean(dep_delay, na.rm = TRUE)) %>%
ggplot(aes(x = factor(month), y = dest, fill = dep_delay)) +
geom_tile() +
labs(x = "Month", y = "Destination", fill = "Departure Delay")
flights %>%
group_by(month, dest) %>%                                 # This gives us (month, dest) pairs
summarise(dep_delay = mean(dep_delay, na.rm = TRUE)) %>%
group_by(dest) %>%                                        # group all (month, dest) pairs by dest ..
filter(n() == 12) %>%                                     # and only select those that have one entry per month
ungroup() %>%
mutate(dest = reorder(dest, dep_delay)) %>%
ggplot(aes(x = factor(month), y = dest, fill = dep_delay)) +
geom_tile() +
labs(x = "Month", y = "Destination", fill = "Departure Delay")
#> `summarise()` regrouping output by 'month' (override with `.groups` argument)
ggplot(smaller, aes(x = carat, y = price)) +
geom_point()
ggplot(diamonds, aes(x = carat, y = price)) +
geom_point()
smaller <- diamonds %>%
filter(carat <= 2.5)
ggplot(smaller, aes(x = carat, y = price)) +
geom_point()
ggplot(smaller, aes(x = carat, y = price)) +
geom_point(alpha = 1/100)
ggplot(smaller, aes(x = carat, y = price)) +
geom_bin2d()
library(hexbin)
install.packages("hexbin")
library(hexbin)
ggplot(smaller, aes(x = carat, y = price)) +
geom_hex()
ggplot(smaller, aes(x = carat, y = price)) +
geom_boxplot(aes(group = cut_width(carat, 0.1)))
# first create the dataframe which we will be working with
mouse.data <- data.frame(
weight=c(0.9, 1.8, 2.4, 3.5, 3.9, 4.4, 5.1, 5.6, 6.3),
size=c(1.4, 2.6, 1.0, 3.7, 5.5, 3.2, 3.0, 4.9, 6.3)
)
# you can also just load in an existing dataframe too
# first create the dataframe which we will be working with
mouse.data <- data.frame(
weight=c(0.9, 1.8, 2.4, 3.5, 3.9, 4.4, 5.1, 5.6, 6.3),
size=c(1.4, 2.6, 1.0, 3.7, 5.5, 3.2, 3.0, 4.9, 6.3)
)
# you can also just load in an existing dataframe too
mouse.data
# Now, we want to look at a basic plot of the data to see what it is doing
plot(mouse.data$weight, mouse.data$size)
# we can now set up the linear regression
mouse.regression <- lm(size ~ weight, data=mouse.data)
# we can now set up the linear regression
# we call the lm(linear model) function, and pass it a formula and the mouse data
# the formula is `y-values = y-intercept + slope x x-values`
# size = y-intercept + slope x weight
mouse.regression <- lm(size ~ weight, data=mouse.data)
summary(mouse.regression)
abline(mouse.regression, col="blue")
# first create the dataframe which we will be working with
mouse.data <- data.frame(
weight=c(0.9, 1.8, 2.4, 3.5, 3.9, 4.4, 5.1, 5.6, 6.3),
size=c(1.4, 2.6, 1.0, 3.7, 5.5, 3.2, 3.0, 4.9, 6.3)
)
# you can also just load in an existing dataframe too
mouse.data
# Now, we want to look at a basic plot of the data to see what it is doing
plot(mouse.data$weight, mouse.data$size)
# we can now set up the linear regression
# we call the lm(linear model) function, and pass it a formula and the mouse data
# the formula is `y-values = y-intercept + slope x x-values`
# size = y-intercept + slope x weight
mouse.regression <- lm(size ~ weight, data=mouse.data)
summary(mouse.regression)
# now, we can add the regression line to the graph from before
abline(mouse.regression, col="blue")
# now, we can add the regression line to the graph from before
plot(mouse.data$weight, mouse.data$size)
abline(mouse.regression, col="blue")
# first create the dataframe which we will be working with
mouse.data <- data.frame(
weight=c(0.9, 1.8, 2.4, 3.5, 3.9, 4.4, 5.1, 5.6, 6.3),
size=c(1.4, 2.6, 1.0, 3.7, 5.5, 3.2, 3.0, 4.9, 6.3),
tail=c(0.7, 1.3, 0.7, 2.0, 3.6, 3.0, 2.9, 3.9, 4.0)
)
# you can also just load in an existing dataframe too
mouse.data
plot(mouse.data$weight, mouse.data$size)
simple.regression <- lm(size ~ weight, data=mouse.data)
simple.regression <- lm(size ~ weight, data=mouse.data)
# in R, we specify the relationship we are looking for by using the `~` character
# in this example, we specify size is predicted by weight
summary(simple.regression)
plot(mouse.data$weight, mouse.data$size)
abline(simple.regression, col="red", lwd=2)
plot(mouse.data)
multiple.regression <- lm(size ~ weight + tail, data=mouse.data)
# the actual formula being used is: `size = y-intercept + slope1 x weight + slope2 x tail`
# we are specifying that size is predicted by weight and tail
summary(multiple.regression)
