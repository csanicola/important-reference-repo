mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)
) +
geom_point() +
geom_smooth(method = "lm") # smoothing is to add the line and "lm" is to say we want to draw a line of best fit based on the linear model
# using the method this way the lines are separated because the colors are separated in the aes() function aka the global level but if we move it to the geom_point() function aka the local level then its a singular line
ggplot(
data = penguins,
mapping = aes(x = flipper_length_mm, y = body_mass_g)
) +
geom_point(mapping = aes(color = species)) +
geom_smooth(method = "lm")
# to account for color blindness or issues with visualizing the colors, adding different shapes to the plots is another way to differentiate the data
ggplot(
data = penguins,
mapping = aes(x = flipper_length_mm, y = body_mass_g)
) +
geom_point(mapping = aes(color = species, shape = species)) +
geom_smooth(method = "lm")
# another thing is adding labels so it's easier to understand because sometimes the variable names from the table are coding in a way other people might not understand
# you would use the lab() function for this
ggplot(
data = penguins,
mapping = aes(x = flipper_length_mm, y = body_mass_g)
) +
geom_point(aes(color = species, shape = species)) +
geom_smooth(method = "lm") +
labs(
title = "Body mass and flipper length",
subtitle = "Dimensions for Adelie, Chinstrap, and Gentoo Penguins",
x = "Flipper length (mm)", y = "Body mass (g)",
color = "Species", shape = "Species"
) +
scale_color_colorblind() # this is a function to pick colorblind safe colors
ggplot(
data = penguins,
mapping = aes(x = bill_length_mm, y = bill_depth_mm)
) +
geom_point()
ggplot(
data = penguins,
mapping = aes(x = species, y = bill_depth_mm)
) +
geom_point()
ggplot(
data = penguins,
mapping = aes(x = species, y = bill_depth_mm)
) +
geom_bar()
ggplot(data = penguins) +
geom_point()
# Install and Load Packages
install.packages("tidyverse")
# or
head(namcshc2023)
# -------------------------------------------------------------------------
# Using R with the 2023 National Ambulatory Medical Care Survey Health Center
# (NAMCS HC) Component Public Use Data File
#
# Please follow the steps below to load the 2023 NAMCS HC Component public use
# data file into R.
#
# 1. Create a new folder on your local workstation, for example, C:\namcshc2023.
#
# 2. Download the namcshc2023_r.rds file from the website and save to the folder
# C:\namcshc2023.
#
# Please note that this program will replace the dataset in the default
# directory, if one is present.
#
# For details and guidance on how to properly conduct statistical analyses
# with these data, including the appropriate use of weights to create
# nationally representative estimates, please refer to the technical
# documentation that accompanies the 2023 NAMCS Health Center Component.
#
# For any questions, suggestions, or comments concerning NAMCS HC Component data,
# please contact the Division of Health Care Statistics at ambcare@cdc.gov.
# -------------------------------------------------------------------------
# Install and Load Packages
install.packages("tidyverse")
# Read in NAMCS HC 2023  Public Use File R Dataset
namcshc2023 <- read_rds("//C://namcshc2023//namcshc2023_r.rds")
namcshc2023 <- read_rds("//C://namcshc2023//namcshc2023_r.rds")
# Install and Load Packages
install.packages("tidyverse")
# Install and Load Packages
install.packages("tidyverse")
Yeslibrary("tidyverse")
# Install and Load Packages
install.packages("tidyverse")
install.packages("systemfonts", type = "source")
install.packages("ragg", type = "source")
# 1. Getting Started with R
# 1.2.1 Basic Computations Objects
# Addition
5+6
# if you want to run all lines of code in our script, you would use the source button but
# you can use the source function
source("Mastering_Health_Science_Using_R.R")
# calling a function
# ceiling() returns the ceiling of your input
# floor() returns the floor of your input
# round() rounds your input to the closest integer
ceiling(3.7)
# you can also see what the current working directory is by using getwd()
getwd()
# to set the current working directory, you can use setwd()
setwd('/Users/carolinesanicola/Documents/GitHub/important-reference-repo/R')
# check
getwd()
# now update the path to the csv file
df <- read.csv("https://github.com/alicepaul/health-data-science-using-r/blob/main/book/data/fake_names.csv")
# now update the path to the csv file
df <- read.csv("https://github.com/alicepaul/health-data-science-using-r/blob/b71bbec95709d0107c166d97654890b9500678ef/book/data/fake_names.csv")
# now update the path to the csv file
df <- read.csv("https://raw.githubusercontent.com/alicepaul/health-data-science-using-r/b71bbec95709d0107c166d97654890b9500678ef/book/data/fake_names.csv")
df
# the most important thing to do is download packages and one of the most important is 'tidyverse'
# to see what packages are already installed use `installed.packages()`
installed.packages()
# the most important package to download is tidyverse
install.package('todyverse')
# the most important package to download is tidyverse
install.packages('tidyverse')
library(tidyverse)
# an object is a named instance of a data structure
ex_num <- 4
# 2.1 Data Types
# each individual value in R has a type: logical, integer, double or character
# you can use typeof() function to find the type of vector
typeof(ex_num)
typeof(ex_int)
# double is a numeric value with a stored decimal
# an integer is a whole number without a decimal
# to indicate we want the number to be an integer object, you need to use `L` after the number
ex_int <- 4L
typeof(ex_int)
# characters have letters
ex_char <- "Alice"
# logicals or booleans are TRUE and FALSE
ex_bool <- TRUE
typeof(ex_char)
typeof(ex_bool)
# booleans can actually be interpreted as 0/1 and can be used in logic
TRUE + FALSE + TRUE
library("tidyverse")
library("nycflights13")
install.packages("ggbeeswarm")
library("ggbeeswarm")
install.packages("lvplot")
library("lvplot")
install.packages("ggstance")
library("ggstance")
nycflights13::flights %>%
mutate(
cancelled = is.na(dep_time),
sched_hour = sched_dep_time %/% 100,
sched_min = sched_dep_time %% 100,
sched_dep_time = sched_hour + sched_min / 60
) %>%
ggplot(aes(x = sched_dep_time)) +
geom_freqpoly(aes(color = cancelled), bunwidth = 1/4)
nycflights13::flights |>
mutate(
cancelled = is.na(dep_time),
sched_hour = sched_dep_time %/% 100,
sched_min = sched_dep_time %% 100,
sched_dep_time = sched_hour + (sched_min / 60)
) |>
ggplot(aes(x = sched_dep_time)) +
geom_freqpoly(aes(color = cancelled), binwidth = 1/4)
nycflights13::flights %>%
mutate(
cancelled = is.na(dep_time),
sched_hour = sched_dep_time %/% 100,
sched_min = sched_dep_time %% 100,
sched_dep_time = sched_hour + sched_min / 60
) %>%
ggplot() +
geom_boxplot(mapping = aes(y = sched_dep_time, x = cancelled))
mean(c(0, 1, 2, NA), na.rm = TRUE)
sum(c(0, 1, 2, NA), na.rm = TRUE)
nycflights13::flights %>%
mutate(
cancelled = is.na(dep_time),
sched_hour = sched_dep_time %/% 100,
sched_min - sched_dep_time %/% 100,
sched_dep_time = sched_hour + sched_min / 60
) %>%
ggplot() +
geom_boxplot(mapping = aes(y = sched_dep_time, x = cancelled))
nycflights13::flights %>%
mutate(
cancelled = is.na(dep_time),
sched_hour = sched_dep_time %/% 100,
sched_min = sched_dep_time %/% 100,
sched_dep_time = sched_hour + sched_min / 60
) %>%
ggplot() +
geom_boxplot(mapping = aes(y = sched_dep_time, x = cancelled))
ggplot(diamonds, aes(x = price)) +
geom_freqpoly(aes(color = cut), binwidth = 500, linewidth = 1)
ggplot(diamonds, aes(x = price)) +
geom_freqpoly(aes(color = cut), binwidth = 500, linewidth = 0.75)
ggplot(diamonds, aes(x = price)) +
geom_freqpoly(aes(color = cut), binwidth = 500, linewidth = 1)
ggplot(mpg, aes(x = class, y = hwy)) +
geom_boxplot()
ggplot(mpg, aes(x = fct_reorder(class, hwy, median), y = hwy)) + # the previous defaulted to alphabetical order for class but if we want to sort it by median value instead then you would use fct_reorder and specify how you want it reordered
geom_boxplot()
ggplot(mpg, aes(y = hwy, x = fct_reorder(class, hwy, median))) + # since the names are long, we want to make the display horizontal and you would do that by switching the x and y
geom_boxplot()
ggplot(mpg, aes(x = fct_reorder(class, hwy, median), y = hwy)) + # the previous defaulted to alphabetical order for class but if we want to sort it by median value instead then you would use fct_reorder and specify how you want it reordered
geom_boxplot()
ggplot(mpg, aes(y = hwy, x = fct_reorder(class, hwy, median))) + # since the names are long, we want to make the display horizontal and you would do that by switching the x and y
geom_boxplot()
ggplot(mpg, aes(x = hwy, y = fct_reorder(class, hwy, median))) + # since the names are long, we want to make the display horizontal and you would do that by switching the x and y
geom_boxplot()
nycflights13::flights %>%
mutate(
cancelled = is.na(dep_time),
sched_hour = sched_dep_time %/% 100,
sched_min = sched_dep_time %% 100,
sched_dep_time = sched_hour + sched_min / 60
) %>%
ggplot() +
geom_boxplot(mapping = aes(y = sched_dep_time, x = cancelled))
ggplot(nycflights13::flights, aes(x = scheduled_dep_time, y = after_stat(density))) +
geom_freqpoly(aes(color = cancelled))
nycflights13::flights |>
mutate(
cancelled = is.na(dep_time),
sched_hour = sched_dep_time %/% 100,
sched_min = sched_dep_time %% 100,
sched_dep_time = sched_hour + (sched_min / 60)
) |>
ggplot(aes(x = sched_dep_time)) +
geom_freqpoly(aes(color = cancelled), binwidth = 1/4)
nycflights13::flights |>
mutate(
cancelled = is.na(dep_time),
sched_hour = sched_dep_time %/% 100,
sched_min = sched_dep_time %% 100,
sched_dep_time = sched_hour + (sched_min / 60)
) |>
ggplot(aes(x = sched_dep_time)) +
geom_freqpoly(aes(color = cancelled), binwidth = 500)
nycflights13::flights |>
mutate(
cancelled = is.na(dep_time),
sched_hour = sched_dep_time %/% 100,
sched_min = sched_dep_time %% 100,
sched_dep_time = sched_hour + (sched_min / 60)
) |>
ggplot(aes(x = sched_dep_time)) +
geom_freqpoly(aes(color = cancelled), binwidth = 1)
nycflights13::flights |>
mutate(
cancelled = is.na(dep_time),
sched_hour = sched_dep_time %/% 100,
sched_min = sched_dep_time %% 100,
sched_dep_time = sched_hour + (sched_min / 60)
) |>
ggplot(aes(x = sched_dep_time)) +
geom_freqpoly(aes(color = cancelled), binwidth = 1/2)
ggplot(flights_data, aes(x = scheduled_dep_time, fill = cancelled)) +
geom_bar(position = "identity", alpha = 0.6) + # Use position="identity" for overlapping bars
facet_wrap(~cancelled, scales = "free_y") + # Key: scales="free_y" for different y-axes
labs(title = "Flight Cancellations by Scheduled Departure Time",
x = "Scheduled Departure Time",
y = "Count",
fill = "Cancelled") +
theme_minimal()
ggplot(nycflights13::flights, aes(x = scheduled_dep_time, fill = cancelled)) +
geom_bar(position = "identity", alpha = 0.6) + # Use position="identity" for overlapping bars
facet_wrap(~cancelled, scales = "free_y") + # Key: scales="free_y" for different y-axes
labs(title = "Flight Cancellations by Scheduled Departure Time",
x = "Scheduled Departure Time",
y = "Count",
fill = "Cancelled") +
theme_minimal()
nycflights13::flights %>%
mutate(
cancelled = is.na(dep_time),
sched_hour = sched_dep_time %/% 100,
sched_min = sched_dep_time %% 100,
sched_dep_time = sched_hour + sched_min / 60
) %>%
ggplot(mapping = aes(x=sched_dep_time, y=..density..)) +
geom_freqpoly(mapping = aes(colour = cancelled), binwidth = .25)+
xlim(c(5,25))
nycflights13::flights %>%
mutate(
cancelled = is.na(dep_time),
sched_hour = sched_dep_time %/% 100,
sched_min = sched_dep_time %% 100,
sched_dep_time = sched_hour + sched_min / 60
) %>%
ggplot(mapping = aes(x=sched_dep_time)) +
geom_density(mapping = aes(fill = cancelled), alpha = 0.30)+
xlim(c(5,25))
nycflights13::flights %>%
mutate(
cancelled = is.na(dep_time),
sched_hour = sched_dep_time %/% 100,
sched_min = sched_dep_time %% 100,
sched_dep_time = sched_hour + sched_min / 60
) %>%
ggplot() +
geom_boxplot(mapping = aes(y = sched_dep_time, x = cancelled))
diamonds?
diamonds?
?diamonds
?diamonds
ggplot(diamonds, aes(x = price, y = cut)) +
geom_boxplot()
###
?diamonds
ggplot(diamonds, aes(x = price, y = carat)) +
geom_boxplot()
###
?diamonds
ggplot(diamonds, aes(x = price, y = color)) +
geom_boxplot()
ggplot(diamonds, aes(x = price, y = clarity)) +
geom_boxplot()
ggplot(diamonds, aes(x = price, y = color)) +
geom_boxplot()
ggplot(data = diamonds, mapping = aes(x = carat, y = price)) +
geom_boxplot(mapping = aes(group = cut_width(carat, 0.1)), orientation = "x")
install.packages("ggstance")
library(ggstance)
coord_flip()?
coord_flip()?
?coord_flip()
ggplot(data = mpg) +
geom_boxplot(mapping = aes(x = reorder(class, hwy, FUN = median), y = hwy)) +
coord_flip()
ggplot(data = mpg) +
geom_boxplot(mapping = aes(y = reorder(class, hwy, FUN = median), x = hwy)) +
coord_flip()
ggplot(data = mpg) +
geom_boxplot(mapping = aes(y = reorder(class, hwy, FUN = median), x = hwy)) +
coord_flip()
ggplot(data = mpg) +
geom_boxplot(mapping = aes(x = reorder(class, hwy, FUN = median), y = hwy)) +
coord_flip()
ggplot(data = mpg) +
geom_boxplot(mapping = aes(y = reorder(class, hwy, FUN = median), x = hwy))
ggplot(data = mpg) +
geom_boxplot(mapping = aes(x = reorder(class, hwy, FUN = median), y = hwy)) +
coord_flip() # this plot shows
ggplot(data = mpg) +
geom_boxplot(mapping = aes(y = reorder(class, hwy, FUN = median), x = hwy))
ggplot(data = mpg) +
geom_boxplot(mapping = aes(y = reorder(class, hwy, FUN = median), x = hwy), orientation = "y")
ggplot(data = mpg) +
geom_boxplot(mapping = aes(y = reorder(class, hwy, FUN = median), x = hwy), orientation = "x") # but you can also explicitly specify the orientation too
ggplot(data = mpg) +
geom_boxplot(mapping = aes(y = reorder(class, hwy, FUN = median), x = hwy), orientation = "y") # but you can also explicitly specify the orientation too
install.packages("lvplot")
library(lvplot)
?geom_lv
ggplot(diamonds, aes(price, cut))
?geom_lv
ggplot(diamonds, aes(price, cut)) +
geom_lv()
ggplot(diamonds, aes(x = price, y = cut)) +
geom_lv()
ggplot(diamonds, aes(x = cut, y = price)) +
geom_lv()
ggplot(diamonds, aes(x = price, y = cut)) +
geom_lv()
ggplot(diamonds, aes(x = cut, y = price)) +
geom_lv()
###
?geom_violin
ggplot(data = diamonds, mapping = aes(x = price, y = ..density..)) +
geom_freqpoly(mapping = aes(color = cut), binwidth = 500)
ggplot(data = diamonds, mapping = aes(x = price)) +
geom_histogram() +
facet_wrap(~cut, ncol = 1, scales = "free_y")
ggplot(data = diamonds, mapping = aes(x = cut, y = price)) +
geom_violin() +
coord_flip()
ggplot(data = diamonds, mapping = aes(x = price)) +
geom_histogram()
ggplot(data = diamonds, mapping = aes(x = price)) +
geom_histogram() +
facet_wrap(~cut, ncol = 1, scales = "free_y")
ggplot(data = diamonds, mapping = aes(x = cut, y = price)) +
geom_violin() +
coord_flip()
ggplot(data = diamonds, mapping = aes(x = price, y = ..density..)) +
geom_freqpoly(mapping = aes(color = cut), binwidth = 500)
ggplot(data = diamonds, mapping = aes(x = price)) +
geom_histogram() +
facet_wrap(~cut, ncol = 1, scales = "free_y")
ggplot(data = diamonds, mapping = aes(x = cut, y = price)) +
geom_violin() +
coord_flip()
install.packages("ggbeeswarm")
library(ggbeeswarm)
?geom_jitter
?ggbeeswarm
?geom_quasirandom
?geom_beeswarm
ggplot(data = mpg) +
geom_quasirandom(mapping = aes(
x = reorder(class, hwy, FUN = median),
y = hwy
))
ggplot(data = mpg) +
geom_quasirandom(
mapping = aes(
x = reorder(class, hwy, FUN = median),
y = hwy
),
method = "tukey"
)
ggplot(data = mpg) +
geom_quasirandom(
mapping = aes(
x = reorder(class, hwy, FUN = median),
y = hwy
),
method = "tukeyDense"
)
ggplot(data = mpg) +
geom_quasirandom(
mapping = aes(
x = reorder(class, hwy, FUN = median),
y = hwy
),
method = "frowney"
)
ggplot(data = mpg) +
geom_quasirandom(
mapping = aes(
x = reorder(class, hwy, FUN = median),
y = hwy
),
method = "smiley"
)
ggplot(data = mpg) +
geom_beeswarm(mapping = aes(
x = reorder(class, hwy, FUN = median),
y = hwy
))
ggplot(diamonds, aes(x = cut, y = color)) +
geom_count()
diamonds %>%
count(color, cut)
diamonds %>%
count(color, cut) %>%
ggplot(aes(x = color, y = cut)) +
geom_tile(aes(fill = n))
diamonds %>%
count(color, cut) %>%
group_by(color) %>%
mutate(prop = n / sum(n)) %>%
ggplot(mapping = aes(x = color, y = cut)) +
geom_tile(mapping = aes(fill = prop))
diamonds %>%
count(color, cut) %>%
group_by(cut) %>%
mutate(prop = n / sum(n)) %>%
ggplot(mapping = aes(x = color, y = cut)) +
geom_tile(mapping = aes(fill = prop))
###
?geom_tile
flights %>%
group_by(month, dest) %>%
summarise(sep_delay = mean(dep_delay, na.rm = TRUE)) %>%
ggplot(aes(x = factor(month), y = dest, fill = dep_delay)) +
geom_tile() +
labs(x = "Month", y = "Destination", fill = "Departure Delay")
flights %>%
group_by(month, dest) %>%
summarise(dep_delay = mean(dep_delay, na.rm = TRUE)) %>%
ggplot(aes(x = factor(month), y = dest, fill = dep_delay)) +
geom_tile() +
labs(x = "Month", y = "Destination", fill = "Departure Delay")
flights %>%
group_by(month, dest) %>%                                 # This gives us (month, dest) pairs
summarise(dep_delay = mean(dep_delay, na.rm = TRUE)) %>%
group_by(dest) %>%                                        # group all (month, dest) pairs by dest ..
filter(n() == 12) %>%                                     # and only select those that have one entry per month
ungroup() %>%
mutate(dest = reorder(dest, dep_delay)) %>%
ggplot(aes(x = factor(month), y = dest, fill = dep_delay)) +
geom_tile() +
labs(x = "Month", y = "Destination", fill = "Departure Delay")
#> `summarise()` regrouping output by 'month' (override with `.groups` argument)
ggplot(smaller, aes(x = carat, y = price)) +
geom_point()
ggplot(diamonds, aes(x = carat, y = price)) +
geom_point()
smaller <- diamonds %>%
filter(carat <= 2.5)
ggplot(smaller, aes(x = carat, y = price)) +
geom_point()
ggplot(smaller, aes(x = carat, y = price)) +
geom_point(alpha = 1/100)
ggplot(smaller, aes(x = carat, y = price)) +
geom_bin2d()
library(hexbin)
install.packages("hexbin")
library(hexbin)
ggplot(smaller, aes(x = carat, y = price)) +
geom_hex()
ggplot(smaller, aes(x = carat, y = price)) +
geom_boxplot(aes(group = cut_width(carat, 0.1)))
