# /'s show path to "getting_started_with_R" folder
setwd("D:/GitHub/important-reference-repo/R/data/")
# Read in the data using read.csv function and assign it to the
# object called mydata
mydata <- read.csv("D:/GitHub/important-reference-repo/R/data/compensation.csv")
# make sure the data are what I wanted
head(mydata)
str(mydata)
# Calculate mean of each group using tapply, which returns a matrix
mean.fruit <- tapply(mydata$Fruit, list(mydata$Grazing), mean)
mean.fruit
# Calculate standard deviation of each group
# using tapply, which returns a matrix-it will be the same dimension as mean.fruit
sd.fruit <- tapply(mydata$Fruit, list(mydata$Grazing), sd)
sd.fruit
# Calculate sample size in each group
n.fruit <- tapply(mydata$Fruit, list(mydata$Grazing), length)
n.fruit
# make a barplot using the means returned from tapply
barplot(mean.fruit)
barplot(mean.fruit,
xlab = "Treatment",
ylab = "Fruit Production",
ylim = c(0,100)) # c is a function in R that is for combining values into a vector; since the ylim needs a min and max for the axis, we use a vector to do this
mids <- barplot(mean.fruit,
xlab = "Treatment",
ylab = "Fruit Production",
ylim = c(0,100))
mids
# Make a barplot using the means returned from tapply
mids <- barplot(mean.fruit,
xlab = "Treatment",
ylab = "Fruit Production",
ylim = c(0,100))
# Use the arrows to put error bars on the plot
arrows(mids, mean.fruit - sd.fruit, mids, mean.fruit + sd.fruit,
code = 3, # tells arrows to draw "arrows" at both ends of the line
angle = 90, # makes the arrow heads 90 degrees-flat
length = 0.1) # makes them short (0.1 mm)
# Make a barplot using the means returned from tapply
mids <- barplot(mean.fruit,
xlab = "Treatment",
ylab = "Fruit Production",
ylim = c(0,100))
# Use the arrows to put error bars on the plot
arrows(mids, mean.fruit - sd.fruit, mids, mean.fruit + sd.fruit,
code = 3, # tells arrows to draw "arrows" at both ends of the line
angle = 90, # makes the arrow heads 90 degrees-flat
length = 0.1) # makes them short (0.1 mm)
# Add text at the midpoints (x) and at height 2 on the y-axis
# paste the words n=followed by the n.fruit values
text(mids, 6, paste("n=", n.fruit))
?barplot
# load in the data
cow_growth <- read.csv("D:/GitHub/important-reference-repo/R/data/growth.csv")
# Calculate mean of each group using tapply, which returns a matrix
mean.comb <- tapply(cow_growth$gain, list(cow_growth$supplement, cow_growth$diet), mean)
# Calculate standard deviation of each group
sd.comb <- tapply(cow_growth$gain, list(cow_growth$supplement, cow_growth$diet), sd)
# Calculate sample size in each group
n.comb <- tapply(cow_growth$gain, list(cow_growth$supplement, cow_growth$diet), length)
# x is Feed; y is Weight Gain; legend is supplement
# make a barplot using the means returned from tapply
mids <- barplot(mean.comb,
beside = TRUE,
main = "Types of Feeds and Supplements by Weight Gain",
xlab = "Feed",
ylab = "Weight Gain",
ylim = c(0,max(mean.comb + sd.comb, na.rm = TRUE) *1.2),
legend.text = rownames(mean.comb),
args.legend = list(x = "topright"))
# Use Arrows to put error bars on the plot
arrows(mids, mean.comb - sd.comb, mids, mean.comb + sd.comb,
code = 3, angle = 90, length = 0.1)
# Add text at the midpoints(x) and at height 6 on the y-axis
# paste the words n=followed by the n.gain values
text(mids, 2, paste("n=", n.comb))
plot(mydata$Root, mydata$Fruit)
# this executes the same things as above
plot(Fruit ~ Root, data = mydata)
plot(Fruit ~ Root, data = mydata,
xlab = list("Root Biomass", cex = 1.5), # increases the default size by 1.5 times
ylab = list("Fruit Production", cex = 0.5)) # decreases the size by 0.5 times (half)
?par
?points
plot(Fruit ~ Root, data = mydata,
xlab = list("Root Biomass", cex = 1.5),
ylab = list("Fruit Production", cex = 0.5),
cex = 2, pch = 21, bg = "grey")
culr <- ifelse(mydata$Grazing == "Grazed", "green", "blue")
plot(Fruit ~ Root, data = mydata,
xlab = list("Root Biomass", cex = 1.5),
ylab = list("Fruit Production", cex = 0.5),
cex = 2, pch = 21, bg = culr)
?legend
culr <- ifelse(mydata$Grazing == "Grazed", "green", "blue")
plot(Fruit ~ Root, data = mydata,
xlab = list("Root Biomass", cex = 1.5),
ylab = list("Fruit Production", cex = 0.5),
cex = 2, pch = 21, bg = culr)
legend("topleft", legend = c("Grazed", "Ungrazed"), # this is going to stick the legend in the top left corner of the plot
pch = 21, pt.bg = c("green", "blue"), pt.cex = 2)
culr <- ifelse(mydata$Grazing == "Grazed", "green", "blue")
plot(Fruit ~ Root, data = mydata,
xlab = list("Root Biomass", cex = 1.5),
ylab = list("Fruit Production", cex = 0.5),
cex = 2, pch = 21, bg = culr)
legend(5, 110, legend = c("Grazed", "Ungrazed"), # this is going to put the legend at plot point (5,110) on the graph
pch = 21, pt.bg = c("green", "blue"), pt.cex = 2)
# This snippet of code writes a pdf of a multi-panel plot to your hard drive.
# It firsts creates some fake data.
# It then opens a pdf "device" on your computer which prepares your
# working directory to receive a pdf.
# It then executes some plotting code and writes the pdf to the working
# directory with a specific filename you have specified.
# Finally, the dev.off  () function closes the connection to the
# working directory, turning off   the pdf device; this final step
# ensures that subsequent plotting is written to the graphics window
# Make the data
time <- seq(0,9.9,0.1) # a sequence
weight <- (time^2) + rnorm(100,0,10) # time^2 with deviation
temperature <- factor(sample(c("cold","hot"), 100, replace = TRUE))
# Identify your working directory - this is where the PDF will be found
getwd()
# OPEN THE PDF DEVICE—specify a file name and a paper size
pdf(file = "PracticePDF.pdf", paper = "a4")
# set the layout of the plotting
# here we specify a 2 x 2 plot and place the figures into the plot by row
layout(matrix(c(1, 2, 3, 4), 2, 2, byrow = TRUE))
# do your plotting—here we add three figures to the layout
# we also use the function mtext() to add letters outside each of the
# boxes as identifiers for a figure legend in your manuscript
plot(weight ~ time, pch = 21, bg = "green")
mtext("A", side = 3, line = 2, adj = 0)
plot(weight ~ temperature)
mtext("B", side = 3, line= 2, adj = 0)
plot(weight ~ time, col = c("black","red")[temperature])
mtext("C", side = 3, line = 2, adj = 0)
# Close the connection to your hard drive
dev.off() # this NEEDS to be there or else you wont be able to actually access the pdf
# Now, go to your hard drive and look in the working directory for the pdf.
# This snippet of code shows the basics of the lattice
# library using the function xyplot()
# First, we load the package lattice as a library
library(lattice) # Comes with the base installation of R
# Now we make up some data
time <- seq(0, 9.9, 0.1) # a sequence
weight <- (time^2) + rnorm(100, 0, 10) # time^2 with deviation
# random assignment of temperature
temperature <- factor(sample(c("cold", "hot"), 100,
replace = TRUE))
# Now, we use xyplot in two different ways
# First, we use the panel plot functionality via the "|" symbol
# (also known as a pipe)
# this creates two panels of weight versus time, each panel
# representing the two temperatures
xyplot(weight ~ time|temperature)
# Next we use the groups argument to color each symbol according
# to the two different temperatures:
xyplot(weight ~ time, groups = temperature)
ladybirds <- read.csv("D:/GitHub/important-reference-repo/R/data/ladybirds.csv")
count_table <- table(ladybirds$Habitat, ladybirds$colour)
print(count_table)
# we are going to create a matrix of the
chi.data <- matrix(c(115, 30, 85, 70), 2, 2, byrow = TRUE,
dimnames = list(c("Black", "Red"), c("Industrial", "Rural")))
barplot(chi.data, beside = TRUE, col = c("Black", "Red"),
ylim = c(0,125), legend = TRUE)
chisq.test(chi.data)
my.chi <- chisq.test(chi.data)
names(my.chi)
my.chi$expected
ozone <- read.csv("D:/GitHub/important-reference-repo/R/data/gardens.csv")
names(ozone)
head(ozone)
str(ozone)
# Read in the data
ozone <- read.csv("D:/GitHub/important-reference-repo/R/data/gardens.csv")
# Check the data
head(ozone)
str(ozone)
# subset the data
GA <- ozone[ozone$Garden == "A", ]
GB <- subset(ozone, Garden == "B")
# make a single figure with two plots (2 rows, 1 column plotting grid)
par(mfrow = c(2, 1))
hist(GA$Ozone)
hist(GB$Ozone)
# set the layout
par(mfrow = c(2, 1))
# Add the histograms with fixed x axis range
hist(GA$Ozone, col = "grey40", main = "", xlim = c(0, 7),
xlab = "A-Ozone")
hist(GB$Ozone, col = "grey80", main = "", xlim = c(0, 7),
xlab = "B-Ozone")
# do a t.test now
t.test(GA$Ozone, GB$Ozone)
limp <- read.csv("D:/GitHub/important-reference-repo/R/data/limpet.csv")
names(limp)
head(limp)
str(limp)
# plot window
par(mfrow = c(1,1))
# the plot
plot(EGGS ~ DENSITY, data = limp, pch = 19, cex = 1.5,
col = c("black", "red")[limp$SEASON],
xlab = list("Density", cex = 1.2),
ylab = list("Eggs Produced", cex = 1.2))
# add a legend
legend(35, 3, legend = c("spring", "summer"),
col = c("black", "red"), pch = c(19, 19))
head(limp)  # View first few rows
summary(limp$EGGS)  # Check for NA values
summary(limp$DENSITY)
# Test minimal plot (no styling)
plot(limp$DENSITY, limp$EGGS)  # Do points appear?
# Test minimal plot (no styling)
plot(limp$DENSITY, limp$EGGS)  # Do points appear?
# Check color assignment
colors_used <- c("black", "red")[limp$SEASON]
head(colors_used)  # Should alternate black/red
# Check color assignment
colors_used <- c("black", "red")[limp$SEASON]
head(colors_used)  # Should alternate black/red
rm(list=ls())
# list=ls() is asking R to make a list of these objects
# rm() asks R to remove all of these objects from this list
# ls() gives a list of all objects in R's "brain"
# ------------------------------------------
# User Name
# January 1, 2000
# Analysis of Trends
# ------------------------------------------
# Reset R's brain
rm(list=ls())
# getwd tells you where R is currently looking
getwd()
# setwd tells R where to look
setwd("D:/GitHub/important-reference-repo/R")
# use getwd to confirm that R is now looking here
getwd()
comp.dat <- read.csv('D:/GitHub/important-reference-repo/R/data/compensation.csv')
ls() # this will show that the new dataset has been loaded in
# Check the data - confirm it is what you expected
names(comp.dat) # returns the names of the columns
head(comp.dat) # returns the first 6 rows
dim(comp.dat) # returns the number of rows and columns
str(comp.dat) # a powerful compilation of the above
summary(comp.dat)
comp.dat[,1] # returns the first column of data
comp.dat[1,] # returns the first row of data
comp.dat[,1:3] # returns first three columns of data
comp.dat[1:3,] # returns the first three rows of data
comp.dat[1:3,1:3] # returns the first three rows and three columns of data
comp.dat[,'Fruit'] # you can use the actual column names too
comp.dat$Grazing
# if we want to look at the subset of data in the comp.dat df where we look only at the rows which have "Grazed" in the "Grazing" column
subset(comp.dat, Grazing == "Grazed")
# Set the working directory to the folder with all the stuff in it.
# note ~ for home directory in Mac/Linux/Unix
# /'s show path to "getting_started_with_R" folder
setwd("D:/GitHub/important-reference-repo/R/data/")
# Read in the data using read.csv function and assign it to the
# object called mydata
mydata <- read.csv("D:/GitHub/important-reference-repo/R/data/compensation.csv")
# make sure the data are what I wanted
head(mydata)
str(mydata)
# Calculate mean of each group using tapply, which returns a matrix
mean.fruit <- tapply(mydata$Fruit, list(mydata$Grazing), mean)
mean.fruit
# Calculate standard deviation of each group
# using tapply, which returns a matrix-it will be the same dimension as mean.fruit
sd.fruit <- tapply(mydata$Fruit, list(mydata$Grazing), sd)
sd.fruit
# Calculate sample size in each group
n.fruit <- tapply(mydata$Fruit, list(mydata$Grazing), length)
n.fruit
# make a barplot using the means returned from tapply
barplot(mean.fruit)
barplot(mean.fruit,
xlab = "Treatment",
ylab = "Fruit Production",
ylim = c(0,100)) # c is a function in R that is for combining values into a vector; since the ylim needs a min and max for the axis, we use a vector to do this
mids <- barplot(mean.fruit,
xlab = "Treatment",
ylab = "Fruit Production",
ylim = c(0,100))
mids
# Make a barplot using the means returned from tapply
mids <- barplot(mean.fruit,
xlab = "Treatment",
ylab = "Fruit Production",
ylim = c(0,100))
# Use the arrows to put error bars on the plot
arrows(mids, mean.fruit - sd.fruit, mids, mean.fruit + sd.fruit,
code = 3, # tells arrows to draw "arrows" at both ends of the line
angle = 90, # makes the arrow heads 90 degrees-flat
length = 0.1) # makes them short (0.1 mm)
# Make a barplot using the means returned from tapply
mids <- barplot(mean.fruit,
xlab = "Treatment",
ylab = "Fruit Production",
ylim = c(0,100))
# Use the arrows to put error bars on the plot
arrows(mids, mean.fruit - sd.fruit, mids, mean.fruit + sd.fruit,
code = 3, # tells arrows to draw "arrows" at both ends of the line
angle = 90, # makes the arrow heads 90 degrees-flat
length = 0.1) # makes them short (0.1 mm)
# Add text at the midpoints (x) and at height 2 on the y-axis
# paste the words n=followed by the n.fruit values
text(mids, 6, paste("n=", n.fruit))
?barplot
# load in the data
cow_growth <- read.csv("D:/GitHub/important-reference-repo/R/data/growth.csv")
# Calculate mean of each group using tapply, which returns a matrix
mean.comb <- tapply(cow_growth$gain, list(cow_growth$supplement, cow_growth$diet), mean)
# Calculate standard deviation of each group
sd.comb <- tapply(cow_growth$gain, list(cow_growth$supplement, cow_growth$diet), sd)
# Calculate sample size in each group
n.comb <- tapply(cow_growth$gain, list(cow_growth$supplement, cow_growth$diet), length)
# x is Feed; y is Weight Gain; legend is supplement
# make a barplot using the means returned from tapply
mids <- barplot(mean.comb,
beside = TRUE,
main = "Types of Feeds and Supplements by Weight Gain",
xlab = "Feed",
ylab = "Weight Gain",
ylim = c(0,max(mean.comb + sd.comb, na.rm = TRUE) *1.2),
legend.text = rownames(mean.comb),
args.legend = list(x = "topright"))
# Use Arrows to put error bars on the plot
arrows(mids, mean.comb - sd.comb, mids, mean.comb + sd.comb,
code = 3, angle = 90, length = 0.1)
# Add text at the midpoints(x) and at height 6 on the y-axis
# paste the words n=followed by the n.gain values
text(mids, 2, paste("n=", n.comb))
plot(mydata$Root, mydata$Fruit)
# this executes the same things as above
plot(Fruit ~ Root, data = mydata)
plot(Fruit ~ Root, data = mydata,
xlab = list("Root Biomass", cex = 1.5), # increases the default size by 1.5 times
ylab = list("Fruit Production", cex = 0.5)) # decreases the size by 0.5 times (half)
?par
?points
plot(Fruit ~ Root, data = mydata,
xlab = list("Root Biomass", cex = 1.5),
ylab = list("Fruit Production", cex = 0.5),
cex = 2, pch = 21, bg = "grey")
culr <- ifelse(mydata$Grazing == "Grazed", "green", "blue")
plot(Fruit ~ Root, data = mydata,
xlab = list("Root Biomass", cex = 1.5),
ylab = list("Fruit Production", cex = 0.5),
cex = 2, pch = 21, bg = culr)
?legend
culr <- ifelse(mydata$Grazing == "Grazed", "green", "blue")
plot(Fruit ~ Root, data = mydata,
xlab = list("Root Biomass", cex = 1.5),
ylab = list("Fruit Production", cex = 0.5),
cex = 2, pch = 21, bg = culr)
legend("topleft", legend = c("Grazed", "Ungrazed"), # this is going to stick the legend in the top left corner of the plot
pch = 21, pt.bg = c("green", "blue"), pt.cex = 2)
culr <- ifelse(mydata$Grazing == "Grazed", "green", "blue")
plot(Fruit ~ Root, data = mydata,
xlab = list("Root Biomass", cex = 1.5),
ylab = list("Fruit Production", cex = 0.5),
cex = 2, pch = 21, bg = culr)
legend(5, 110, legend = c("Grazed", "Ungrazed"), # this is going to put the legend at plot point (5,110) on the graph
pch = 21, pt.bg = c("green", "blue"), pt.cex = 2)
# This snippet of code writes a pdf of a multi-panel plot to your hard drive.
# It firsts creates some fake data.
# It then opens a pdf "device" on your computer which prepares your
# working directory to receive a pdf.
# It then executes some plotting code and writes the pdf to the working
# directory with a specific filename you have specified.
# Finally, the dev.off  () function closes the connection to the
# working directory, turning off   the pdf device; this final step
# ensures that subsequent plotting is written to the graphics window
# Make the data
time <- seq(0,9.9,0.1) # a sequence
weight <- (time^2) + rnorm(100,0,10) # time^2 with deviation
temperature <- factor(sample(c("cold","hot"), 100, replace = TRUE))
# Identify your working directory - this is where the PDF will be found
getwd()
# OPEN THE PDF DEVICE—specify a file name and a paper size
pdf(file = "PracticePDF.pdf", paper = "a4")
# set the layout of the plotting
# here we specify a 2 x 2 plot and place the figures into the plot by row
layout(matrix(c(1, 2, 3, 4), 2, 2, byrow = TRUE))
# do your plotting—here we add three figures to the layout
# we also use the function mtext() to add letters outside each of the
# boxes as identifiers for a figure legend in your manuscript
plot(weight ~ time, pch = 21, bg = "green")
mtext("A", side = 3, line = 2, adj = 0)
plot(weight ~ temperature)
mtext("B", side = 3, line= 2, adj = 0)
plot(weight ~ time, col = c("black","red")[temperature])
mtext("C", side = 3, line = 2, adj = 0)
# Close the connection to your hard drive
dev.off() # this NEEDS to be there or else you wont be able to actually access the pdf
# Now, go to your hard drive and look in the working directory for the pdf.
# This snippet of code shows the basics of the lattice
# library using the function xyplot()
# First, we load the package lattice as a library
library(lattice) # Comes with the base installation of R
# Now we make up some data
time <- seq(0, 9.9, 0.1) # a sequence
weight <- (time^2) + rnorm(100, 0, 10) # time^2 with deviation
# random assignment of temperature
temperature <- factor(sample(c("cold", "hot"), 100,
replace = TRUE))
# Now, we use xyplot in two different ways
# First, we use the panel plot functionality via the "|" symbol
# (also known as a pipe)
# this creates two panels of weight versus time, each panel
# representing the two temperatures
xyplot(weight ~ time|temperature)
# Next we use the groups argument to color each symbol according
# to the two different temperatures:
xyplot(weight ~ time, groups = temperature)
ladybirds <- read.csv("D:/GitHub/important-reference-repo/R/data/ladybirds.csv")
count_table <- table(ladybirds$Habitat, ladybirds$colour)
print(count_table)
# we are going to create a matrix of the
chi.data <- matrix(c(115, 30, 85, 70), 2, 2, byrow = TRUE,
dimnames = list(c("Black", "Red"), c("Industrial", "Rural")))
barplot(chi.data, beside = TRUE, col = c("Black", "Red"),
ylim = c(0,125), legend = TRUE)
chisq.test(chi.data)
my.chi <- chisq.test(chi.data)
names(my.chi)
my.chi$expected
ozone <- read.csv("D:/GitHub/important-reference-repo/R/data/gardens.csv")
names(ozone)
head(ozone)
str(ozone)
# Read in the data
ozone <- read.csv("D:/GitHub/important-reference-repo/R/data/gardens.csv")
# Check the data
head(ozone)
str(ozone)
# subset the data
GA <- ozone[ozone$Garden == "A", ]
GB <- subset(ozone, Garden == "B")
# make a single figure with two plots (2 rows, 1 column plotting grid)
par(mfrow = c(2, 1))
hist(GA$Ozone)
hist(GB$Ozone)
# set the layout
par(mfrow = c(2, 1))
# Add the histograms with fixed x axis range
hist(GA$Ozone, col = "grey40", main = "", xlim = c(0, 7),
xlab = "A-Ozone")
hist(GB$Ozone, col = "grey80", main = "", xlim = c(0, 7),
xlab = "B-Ozone")
# do a t.test now
t.test(GA$Ozone, GB$Ozone)
limp <- read.csv("D:/GitHub/important-reference-repo/R/data/limpet.csv")
limp$SEASON <- factor(limp$SEASON, levels = c("spring", "summer"))
names(limp)
head(limp)
str(limp)
# Check color assignment
colors_used <- c("black", "red")[limp$SEASON]
head(colors_used)  # Should alternate black/red
# plot window
par(mfrow = c(1,1))
# the plot
plot(EGGS ~ DENSITY, data = limp, pch = 19, cex = 1.5,
col = c("black", "red")[limp$SEASON],
xlab = list("Density", cex = 1.2),
ylab = list("Eggs Produced", cex = 1.2))
# add a legend
legend(35, 3, legend = c("spring", "summer"),
col = c("black", "red"), pch = c(19, 19))
limp.mod <- lm(EGGS ~ DENSITY*SEASON, data = limp) # this is specifying that all we want to include an effect of DENSITY (main effect), as effect of SEASON (main effect), and the potential for the effect of DENSITY to depend on SEASON (interaction)
limp.mod <- lm(EGGS ~ DENSITY*SEASON, data = limp) # this is specifying that all we want to include an effect of DENSITY (main effect), as effect of SEASON (main effect), and the potential for the effect of DENSITY to depend on SEASON (interaction)
names(limp.mod)
par(mfrow = c(2,2)) # make a four panel plot window
plot(limp.mod) # add the four diagnostic plots to the window
hist(limp.mod$resid)
anova(limp.mod)
summary(limp.mod)
names(limp.mod)
coef(limp.mod)
# plot window
par(mfrow = c(1,1))
# the plot
plot(EGGS ~ DENSITY, data = limp, pch = 19, cex = 1.5,
col = c("black", "red")[limp$SEASON],
xlab = list("Density", cex = 1.2),
ylab = list("Eggs Produced", cex = 1.2))
# add a legend
legend(35, 3, legend = c("spring", "summer"),
col = c("black", "red"), pch = c(19, 19))
abline(coef(limp.mod)[1] + coef(limp.mod)[3], # summer intercept
coef(limp.mod)[2] + coef(limp.mod)[4], # summer slope
col="red")
# plot window
par(mfrow = c(1,1))
# the plot
plot(EGGS ~ DENSITY, data = limp, pch = 19, cex = 1.5,
col = c("black", "red")[limp$SEASON],
xlab = list("Density", cex = 1.2),
ylab = list("Eggs Produced", cex = 1.2))
# add a legend
legend(35, 3, legend = c("spring", "summer"),
col = c("black", "red"), pch = c(19, 19))
abline(coef(limp.mod)[1], coef(limp.mod)[2])
abline(coef(limp.mod)[1] + coef(limp.mod)[3], # summer intercept
coef(limp.mod)[2] + coef(limp.mod)[4], # summer slope
col="red")
