---
title: "PCA_in_R"
output: html_document
---

# PCA in R

[Source](https://www.youtube.com/watch?v=0Jp4gsfOLMs)

# Loading Data

-   we are generating a data matrix for this example

```{r}
data.matrix <- matrix(nrow=100, ncol=10) # we are creating a matrix of data with 100 rows and 10 columns
colnames(data.matrix) <- c(
  paste("wt", 1:5, sep=""), # the first 5 columns for the data will all start with "wt" for "wild type"; "wt" are normal, everyday samples
  paste("ko", 1:5, sep="")) # the last 5 columns will be "ko" for "knock-out" samples; these are samples that are missing a gene because we knocked it out
rownames(data.matrix) <- paste("gene", 1:100, sep="") # this is naming each row of data (aka giving each gene a name w/ number)
for (i in 1:100) {
  wt.values <- rpois(5, lambda=sample(x=10:1000, size=1))
  ko.values <- rpois(5, lambda=sample(x=10:1000, size=1))
  
  data.matrix[i, ] <- c(wt.values, ko.values)
} # this is giving each gene a fake read count
head(data.matrix)
```

# PCA

```{r}
# now that we have our fake data, our goal is to draw a plot that will show how our data is related to one another 
# by default: `prcomp()` expects the samples to be rows and the genes to be columns
# since our matrix has the samples as columns and rows as genes (variables), we need to transpose the matrix using the `t()` function
  # without transposing the data, we will get a graph that shows how the genes are related to one another (which is not our goal here)
pca <- prcomp(t(data.matrix), scale=TRUE) 

plot(pca$x[,1], pca$x[,2]) # here we are using the first two columns in x to draw a 2-D plot that uses the first two PCs
# the first column is PC1 so that's on the x-axis and the second column is PC2 so that's on the y-axis
# once we plot the data, we can see there is a cluster of data on the right side and on the left side
# to get a sense of how meaningful these clusters are, we next want to see how much variation in the original data PC1 accounts for
```

```{r}
pca.var <- pca$sdev^2
# to see how much variation is in the original data each principal component (PC) accounts for, we use the square of standard deviation (`sdev`)
pca.var.per <- round(pca.var/sum(pca.var)*100, 1)
# the percentages of how much the variation accounts for is much more important than the actual number so we then calculate the percentages
# we can then plot these percentages with a barplot
barplot(pca.var.per, main="Scree Plot", xlab="Principal Component", ylab="Percent Variation")
# from the barplot, we can see that PC1 accounts for almost all of the variation in the data 
```

```{r}
# we can also make a ggplot that is fancier and supplies much more information
library(ggplot2)

pca.data <- data.frame(Sample=rownames(pca$x), # one column with the sample ids
                       X=pca$x[,1], # these two columns for the X 
                       Y=pca$x[,2]) # and Y coordinates for each sample
pca.data
```

```{r}
# we can now call to the `ggplot()` function
ggplot(data=pca.data, aes(x=X, y=Y, label=Sample)) +
  geom_text() + # the text is used to plot the points as text (the exact gene labels) instead of points or other shapes
  xlab(paste("PC1 - ", pca.var.per[1], "%", sep="")) + # this x axis is going to tell us what percentage of the variation in the original data that PC1 accounts for
  ylab(paste("PC2 - ", pca.var.per[2], "%", sep="")) + # this y axis is going to tell us what percentage of the variation in the original data that PC2 accounts for
  theme_bw() +
  ggtitle("My PCA Graph")
```

```{r}
# we then want to look at the loading scores to see which genes have the largest effect on where samples are plotted in the PCA plot
# the `prcomp()` function calls the loading scores rotations
# each PC has loading scores but since PC1 accounts for 92% of the variation in the data, we will just be looking at the loading scores from PC1
loading_scores <- pca$rotation[,1]
# genes that push samples to the left side of the graph will have large negative values and genes that push the samples to the right side of the graph have large positive values
# since we want to look at both samples, we are going to use the `abs()` (absolute value) function to sort based on the number's magnitude rather than from high to low
gene_scores <- abs(loading_scores)
gene_score_ranked <- sort(gene_scores, decreasing=TRUE) # we now want to sort the magnitudes of the loading scores from high to low
top_10_genes <- names(gene_score_ranked[1:10]) # we can now get the names of the top 10 genes with the largest loading score magnitudes

top_10_genes
```

```{r}
# we can also then see which of these genes have negative loading scores (which push the "wt" samples to the left side of the graph) and which have positive loading scores (push the "wt" samples to the right side of the graph)
pca$rotation[top_10_genes,1] ## show the scores (and +/- sign)
```
